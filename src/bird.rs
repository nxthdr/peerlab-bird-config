use anyhow::{Context, Result};
use sha2::{Digest, Sha256};
use std::fs;
use std::path::Path;
use std::process::Command;
use tracing::{debug, info};

use crate::headscale::Node;

/// Generate BIRD configuration from Headscale nodes
pub fn generate_config(nodes: &[Node]) -> Result<String> {
    let mut config = String::new();

    // Header
    config.push_str("# BIRD Configuration for Peering Course\n");
    config.push_str("# Auto-generated by peerlab-bird-configurator\n");
    config.push_str(&format!(
        "# Generated at: {}\n",
        chrono::Utc::now().to_rfc3339()
    ));
    config.push_str("\n");

    // Filter peerlab nodes (those with user email)
    let peerlab_nodes: Vec<&Node> = nodes.iter().filter(|n| n.has_user_email()).collect();

    info!("Found {} peerlab user nodes", peerlab_nodes.len());

    // Generate IP â†’ ASN mapping function
    config.push_str("# IP to Expected ASN mapping\n");
    config.push_str("# This prevents users from spoofing other users' ASNs\n");
    config.push_str("function get_expected_asn(ip remote_ip) {\n");

    for node in &peerlab_nodes {
        if let Some(ipv4) = node.get_ipv4() {
            let email = node.user.email.as_ref().unwrap();
            // Extract ASN from node name if it follows pattern "peerlab-{asn}"
            // Otherwise, we'll need to query a database - for now, use a placeholder
            let asn = extract_asn_from_node_name(&node.name).unwrap_or(64512);

            config.push_str(&format!(
                "    if (remote_ip = {}) then return {};  # {}\n",
                ipv4, asn, email
            ));
        }
    }

    config.push_str("    return 0;  # Unknown IP\n");
    config.push_str("}\n\n");

    // Import filter with IP-ASN binding check
    config.push_str("# Filter for peerlab imports with ASN verification\n");
    config.push_str("filter PeerlabImportFilter {\n");
    config.push_str("    int expected_asn;\n");
    config.push_str("    int actual_asn;\n");
    config.push_str("\n");
    config.push_str("    actual_asn = bgp_path.last;\n");
    config.push_str("    expected_asn = get_expected_asn(from);\n");
    config.push_str("\n");
    config.push_str("    # Reject unknown IPs\n");
    config.push_str("    if (expected_asn = 0) then {\n");
    config.push_str("        print \"REJECT: Unknown/unauthorized IP \", from;\n");
    config.push_str("        reject;\n");
    config.push_str("    }\n");
    config.push_str("\n");
    config.push_str("    # Verify ASN matches the registered user\n");
    config.push_str("    if (actual_asn != expected_asn) then {\n");
    config.push_str("        print \"SECURITY ALERT: ASN mismatch from \", from, \" - expected AS\", expected_asn, \" but got AS\", actual_asn;\n");
    config.push_str("        reject;\n");
    config.push_str("    }\n");
    config.push_str("\n");
    config.push_str("    # Verify ASN is in private range\n");
    config.push_str("    if (actual_asn >= 64512 && actual_asn <= 65534) then {\n");
    config.push_str(
        "        print \"ACCEPT: AS\", actual_asn, \" prefix \", net, \" from \", from;\n",
    );
    config.push_str("        accept;\n");
    config.push_str("    }\n");
    config.push_str("    if (actual_asn >= 4200000000 && actual_asn <= 4294967294) then {\n");
    config.push_str(
        "        print \"ACCEPT: AS\", actual_asn, \" prefix \", net, \" from \", from;\n",
    );
    config.push_str("        accept;\n");
    config.push_str("    }\n");
    config.push_str("\n");
    config.push_str("    reject;\n");
    config.push_str("}\n\n");

    // Export filter
    config.push_str("# Filter for exports to peerlab - send them the full table\n");
    config.push_str("filter PeerlabExportFilter {\n");
    config.push_str("    # Export our own prefix\n");
    config.push_str("    if (net ~ [ 2a06:de00:50::/48 ]) then {\n");
    config.push_str("        accept;\n");
    config.push_str("    }\n");
    config.push_str("    # Export all learned routes (they'll see the full routing table)\n");
    config.push_str("    if (source = RTS_BGP) then {\n");
    config.push_str("        accept;\n");
    config.push_str("    }\n");
    config.push_str("    reject;\n");
    config.push_str("}\n\n");

    // BGP template
    config.push_str("# Dynamic BGP template for peerlab connections\n");
    config.push_str("template bgp peerlab_template {\n");
    config.push_str("    local 100.64.0.2 as 215011;\n");
    config.push_str("\n");
    config.push_str("    # Allow connections from non-directly connected IPs (via Tailscale)\n");
    config.push_str("    multihop;\n");
    config.push_str("\n");
    config
        .push_str("    # IPv4 channel - only for BGP session establishment, no routes exchanged\n");
    config.push_str("    ipv4 {\n");
    config.push_str("        import none;\n");
    config.push_str("        export none;\n");
    config.push_str("        extended next hop on;\n");
    config.push_str("    };\n");
    config.push_str("\n");
    config.push_str("    # IPv6 channel - exchange IPv6 routes over the IPv4 BGP session\n");
    config.push_str("    ipv6 {\n");
    config.push_str("        import keep filtered;\n");
    config.push_str("        import filter PeerlabImportFilter;\n");
    config.push_str("        export filter PeerlabExportFilter;\n");
    config.push_str("        extended next hop on;\n");
    config.push_str("    };\n");
    config.push_str("\n");
    config.push_str("    # Connection settings\n");
    config.push_str("    hold time 90;\n");
    config.push_str("    keepalive time 30;\n");
    config.push_str("}\n\n");

    // Dynamic BGP protocol
    config.push_str(
        "# Dynamic BGP protocol - accepts connections from peerlab participants via Tailscale\n",
    );
    config.push_str("protocol bgp peerlab from peerlab_template {\n");
    config.push_str("    # Each participant gets their own dynamic session\n");
    config.push_str("    dynamic name \"peerlab_\";\n");
    config.push_str("    dynamic name digits 5;\n");
    config.push_str("\n");
    config.push_str("    # Accept connections from Tailscale range (100.64.0.0/10)\n");
    config.push_str("    neighbor range 100.64.0.0/10 external;\n");
    config.push_str("}\n");

    Ok(config)
}

/// Write configuration to file only if it has changed
/// Returns true if the file was updated
pub fn write_config_if_changed(path: &Path, content: &str) -> Result<bool> {
    // Calculate hash of new content
    let mut hasher = Sha256::new();
    hasher.update(content.as_bytes());
    let new_hash = format!("{:x}", hasher.finalize());

    // Read existing file if it exists
    let existing_hash = if path.exists() {
        let existing_content =
            fs::read_to_string(path).context("Failed to read existing configuration file")?;
        let mut hasher = Sha256::new();
        hasher.update(existing_content.as_bytes());
        format!("{:x}", hasher.finalize())
    } else {
        String::new()
    };

    // Only write if content changed
    if new_hash != existing_hash {
        debug!("Configuration changed, writing to {}", path.display());

        // Write to temporary file first
        let temp_path = path.with_extension("tmp");
        fs::write(&temp_path, content).context("Failed to write temporary configuration file")?;

        // Atomic rename
        fs::rename(&temp_path, path).context("Failed to rename temporary configuration file")?;

        Ok(true)
    } else {
        debug!("Configuration unchanged");
        Ok(false)
    }
}

/// Extract ASN from node name (e.g., "peerlab-64512" -> 64512)
fn extract_asn_from_node_name(name: &str) -> Option<u32> {
    if let Some(asn_str) = name.strip_prefix("peerlab-") {
        asn_str.parse::<u32>().ok()
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_asn_from_node_name() {
        assert_eq!(extract_asn_from_node_name("peerlab-64512"), Some(64512));
        assert_eq!(extract_asn_from_node_name("peerlab-65534"), Some(65534));
        assert_eq!(extract_asn_from_node_name("other-node"), None);
        assert_eq!(extract_asn_from_node_name("peerlab-invalid"), None);
    }
}
